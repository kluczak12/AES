// Funkcja pomocnicza do mnożenia przez 2 (operacja xtime)
private byte xtime(byte b) {
    // Jeśli najbardziej znaczący bit jest ustawiony, po przesunięciu trzeba wykonać XOR z 0x1B.
    return (byte) ((b << 1) ^ (((b & 0x80) != 0) ? 0x1B : 0));
}

// Mnożenie przez 2 w GF(2^8)
private byte mul2(byte b) {
    return xtime(b);
}

// Mnożenie przez 3 w GF(2^8): 3*b = (2*b) XOR b
private byte mul3(byte b) {
    return (byte) (xtime(b) ^ b);
}

private byte[][] mixColumns(byte[][] state) {
    // Zakładamy, że state to macierz 4x4
    for (int col = 0; col < 4; col++) {
        // Przypisanie wartości kolumny do lokalnych zmiennych dla czytelności
        byte b0 = state[0][col];
        byte b1 = state[1][col];
        byte b2 = state[2][col];
        byte b3 = state[3][col];

        // Nowe wartości kolumny zgodnie z transformacją MixColumns w AES:
        state[0][col] = (byte) (mul2(b0) ^ mul3(b1) ^ b2 ^ b3);
        state[1][col] = (byte) (b0 ^ mul2(b1) ^ mul3(b2) ^ b3);
        state[2][col] = (byte) (b0 ^ b1 ^ mul2(b2) ^ mul3(b3));
        state[3][col] = (byte) (mul3(b0) ^ b1 ^ b2 ^ mul2(b3));
    }
    return state;
}





        this.keyWords = key.length / 4;
        this.rounds = keyWords + 6;